<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search - Interlinear Bible Reader</title>
    <link rel="icon" type="image/png" href="https://img.icons8.com/?size=48&id=ho7FUWP8PGIX&format=png">

    <!-- Google Fonts for reading fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&family=EB+Garamond:wght@400;500;600&family=Inter:wght@400;500;600;700&family=Libre+Baskerville:wght@400;700&family=Literata:wght@400;500;600&family=Lora:wght@400;500;600&family=Merriweather:wght@400;700&family=Open+Sans:wght@400;500;600&family=Roboto:wght@400;500;700&family=Source+Serif+4:wght@400;500;600&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="IBRstyle.css">

    <script>
        // Apply saved settings immediately to prevent flash
        const savedPreset = localStorage.getItem('themePreset');
        const savedFont = localStorage.getItem('fontFamily');
        const savedFontSize = localStorage.getItem('fontSize');
        const savedLineHeight = localStorage.getItem('lineHeight');

        if (savedPreset && savedPreset !== 'default') {
            document.documentElement.setAttribute('data-preset', savedPreset);
        }
        if (savedFont && savedFont !== 'system') {
            document.documentElement.setAttribute('data-font', savedFont);
        }
        if (savedFontSize && savedFontSize !== 'medium') {
            document.documentElement.setAttribute('data-font-size', savedFontSize);
        }
        if (savedLineHeight && savedLineHeight !== 'normal') {
            document.documentElement.setAttribute('data-line-height', savedLineHeight);
        }
    </script>
</head>

<body>
    <h1>Interlinear Bible Reader</h1>

    <div id="navBar">
        <a href="index.html" class="nav-back" title="Back to Reader">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </a>
        <span class="nav-title">Search</span>
        <button id="settingsBtn" onclick="window.location.href='settings.html'" title="Settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
        </button>
    </div>

    <div class="search-page">
        <div class="search-container">
            <div class="search-box">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
                <input type="text" id="searchInput" placeholder="Search for words or phrases..." autocomplete="off">
                <button id="searchBtn" title="Search">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="9 18 15 12 9 6"></polyline>
                    </svg>
                </button>
            </div>
            <div class="search-type-toggle">
                <button class="search-type-btn active" data-type="text">Text Search</button>
                <button class="search-type-btn" data-type="strongs">Strong's Number</button>
            </div>
            <div class="search-options" id="textOptions">
                <label class="checkbox-label">
                    <input type="checkbox" id="caseSensitive">
                    <span>Case sensitive</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="wholeWord">
                    <span>Whole word only</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="exactPhrase" checked>
                    <span>Exact phrase</span>
                </label>
            </div>
            <p class="search-hint" id="multiWordHint" style="display: none;">Words can appear anywhere in the verse, in any order.</p>
            <div class="search-options" id="strongsOptions" style="display: none;">
                <p class="search-hint">Enter a Strong's number (e.g., H430, G2316) to find all occurrences of that Hebrew or Greek word.</p>
            </div>
        </div>

        <div id="searchStatus" class="search-status"></div>

        <div id="searchResults" class="search-results"></div>
    </div>

    <script>
        let bibleData = [];
        let isSearching = false;
        let searchType = 'text'; // 'text' or 'strongs'

        // Load Bible data
        fetch('bible.json')
            .then(r => r.json())
            .then(data => {
                bibleData = data;
                handleUrlParams();
            });

        // Handle URL parameters for pre-filled search
        function handleUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const query = urlParams.get('q');
            const type = urlParams.get('type');

            if (type === 'strongs') {
                setSearchType('strongs');
            }

            if (query) {
                document.getElementById('searchInput').value = query;
                // Auto-search after a short delay
                setTimeout(performSearch, 100);
            } else {
                document.getElementById('searchInput').focus();
            }

            // Clear URL params after reading
            if (query || type) {
                window.history.replaceState({}, '', window.location.pathname);
            }
        }

        // Search type toggle
        document.querySelectorAll('.search-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setSearchType(btn.dataset.type);
            });
        });

        function setSearchType(type) {
            searchType = type;
            document.querySelectorAll('.search-type-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-type="${type}"]`).classList.add('active');

            const searchInput = document.getElementById('searchInput');
            const textOptions = document.getElementById('textOptions');
            const strongsOptions = document.getElementById('strongsOptions');

            if (type === 'strongs') {
                searchInput.placeholder = "Enter Strong's number (e.g., H430, G2316)...";
                textOptions.style.display = 'none';
                strongsOptions.style.display = 'flex';
            } else {
                searchInput.placeholder = "Search for words or phrases...";
                textOptions.style.display = 'flex';
                strongsOptions.style.display = 'none';
            }
        }

        // Toggle hint for non-exact phrase search
        document.getElementById('exactPhrase').addEventListener('change', (e) => {
            document.getElementById('multiWordHint').style.display = e.target.checked ? 'none' : 'block';
        });

        // Search functionality
        document.getElementById('searchBtn').addEventListener('click', performSearch);
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') performSearch();
        });

        function performSearch() {
            if (isSearching) return;

            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            isSearching = true;
            const statusEl = document.getElementById('searchStatus');
            const resultsEl = document.getElementById('searchResults');

            statusEl.innerHTML = '<span class="loading">Searching...</span>';
            resultsEl.innerHTML = '';

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                let results;
                if (searchType === 'strongs') {
                    results = searchByStrongs(query);
                } else {
                    const caseSensitive = document.getElementById('caseSensitive').checked;
                    const wholeWord = document.getElementById('wholeWord').checked;
                    const exactPhrase = document.getElementById('exactPhrase').checked;
                    results = searchBible(query, caseSensitive, wholeWord, exactPhrase);
                }
                displayResults(results, query, searchType === 'text' && document.getElementById('caseSensitive').checked);
                isSearching = false;
            }, 50);
        }

        // Strong's number search
        function searchByStrongs(query) {
            const results = [];

            // Normalize the Strong's number (e.g., "h430" -> "H430", "G2316" -> "G2316")
            let strongsNum = query.toUpperCase().trim();
            // Handle various input formats
            if (!strongsNum.match(/^[HG]\d+$/)) {
                // Try to extract number if user just typed digits
                const digits = strongsNum.replace(/\D/g, '');
                if (digits) {
                    // Default to Hebrew if no prefix
                    strongsNum = 'H' + digits;
                }
            }

            const normalizedSearch = strongsNum[0] + strongsNum.slice(1).replace(/^0+/, '');

            bibleData.forEach(item => {
                const parts = item.r.split(':');
                if (parts.length < 4) return;

                const [translation, book, chapter, verseNum] = parts;

                if (item.h || !item.d || !Array.isArray(item.d)) return;

                // Find all words that match the Strong's number
                const matchingWords = [];
                item.d.forEach(wordObj => {
                    if (!wordObj.s || !wordObj.t) return;
                    const storedStrongs = wordObj.s.toUpperCase();
                    const normalizedStored = storedStrongs[0] + storedStrongs.slice(1).replace(/^0+/, '');
                    if (normalizedStored === normalizedSearch) {
                        // Extract English word from "english|original|translit" format
                        const english = wordObj.t.split('|')[0];
                        if (english && !matchingWords.includes(english)) {
                            matchingWords.push(english);
                        }
                    }
                });

                if (matchingWords.length > 0) {
                    const verseText = extractVerseText(item.d);
                    results.push({
                        book,
                        chapter,
                        verse: verseNum,
                        text: verseText,
                        reference: `${book} ${chapter}:${verseNum}`,
                        strongsNum,
                        matchingWords // Array of English words that match
                    });
                }
            });

            return results;
        }

        function searchBible(query, caseSensitive, wholeWord, exactPhrase) {
            const results = [];
            const searchQuery = caseSensitive ? query : query.toLowerCase();

            // For non-exact phrase search, split into words
            const searchWords = exactPhrase ? null : searchQuery.split(/\s+/).filter(w => w.length > 0);

            // Build regex for whole word matching
            let regex = null;
            if (wholeWord && exactPhrase) {
                const escapedQuery = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                regex = new RegExp(`\\b${escapedQuery}\\b`, caseSensitive ? 'g' : 'gi');
            }

            bibleData.forEach(item => {
                // Parse reference - format is "translation:book:chapter:verse"
                const parts = item.r.split(':');
                if (parts.length < 4) return;

                const [translation, book, chapter, verseNum] = parts;

                // Skip headers (items with .h) and items without verse data
                if (item.h || !item.d || !Array.isArray(item.d)) return;

                // Extract text from verse data
                const verseText = extractVerseText(item.d);
                if (!verseText) return;

                const textToSearch = caseSensitive ? verseText : verseText.toLowerCase();

                let matches = false;

                if (!exactPhrase && searchWords && searchWords.length > 1) {
                    // Non-consecutive word search: all words must appear somewhere in the verse
                    matches = searchWords.every(word => {
                        if (wholeWord) {
                            const wordRegex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, caseSensitive ? '' : 'i');
                            return wordRegex.test(textToSearch);
                        }
                        return textToSearch.includes(word);
                    });
                } else if (wholeWord && regex) {
                    matches = regex.test(textToSearch);
                    regex.lastIndex = 0; // Reset regex
                } else {
                    matches = textToSearch.includes(searchQuery);
                }

                if (matches) {
                    results.push({
                        book,
                        chapter,
                        verse: verseNum,
                        text: verseText,
                        reference: `${book} ${chapter}:${verseNum}`
                    });
                }
            });

            return results;
        }

        function extractVerseText(wordArray) {
            let text = '';

            wordArray.forEach(wordObj => {
                if (wordObj.t) {
                    // Format is "english|original|translit" - extract English part
                    const english = wordObj.t.split('|')[0];
                    if (english) {
                        if (text.length > 0) text += ' ';
                        text += english;
                    }
                }
            });

            return text.trim();
        }

        function displayResults(results, query, caseSensitive) {
            const statusEl = document.getElementById('searchStatus');
            const resultsEl = document.getElementById('searchResults');

            if (results.length === 0) {
                statusEl.innerHTML = `<span class="no-results">No results found for "<strong>${escapeHtml(query)}</strong>"</span>`;
                resultsEl.innerHTML = '';
                return;
            }

            const isStrongsSearch = searchType === 'strongs';
            statusEl.innerHTML = `<span class="results-count">Found <strong>${results.length}</strong> result${results.length !== 1 ? 's' : ''} for "<strong>${escapeHtml(query)}</strong>"</span>`;

            // Group results by book
            const groupedResults = {};
            results.forEach(result => {
                if (!groupedResults[result.book]) {
                    groupedResults[result.book] = [];
                }
                groupedResults[result.book].push(result);
            });

            let html = '';
            for (const book in groupedResults) {
                html += `<div class="result-book">
                    <h3 class="book-header">${book} <span class="count">(${groupedResults[book].length})</span></h3>
                    <div class="book-results">`;

                groupedResults[book].forEach(result => {
                    let highlightedText;
                    if (isStrongsSearch && result.matchingWords && result.matchingWords.length > 0) {
                        // Highlight the specific words that match the Strong's number
                        highlightedText = highlightStrongsWords(result.text, result.matchingWords);
                    } else {
                        highlightedText = highlightMatches(result.text, query, caseSensitive);
                    }
                    html += `
                        <a href="index.html?book=${encodeURIComponent(result.book)}&chapter=${result.chapter}&verse=${result.verse}" class="result-item">
                            <span class="result-reference">${result.reference}</span>
                            <span class="result-text">${highlightedText}</span>
                        </a>`;
                });

                html += '</div></div>';
            }

            resultsEl.innerHTML = html;
        }

        function highlightMatches(text, query, caseSensitive) {
            const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(${escapedQuery})`, caseSensitive ? 'g' : 'gi');
            return escapeHtml(text).replace(regex, '<mark>$1</mark>');
        }

        function highlightStrongsWords(text, matchingWords) {
            let result = escapeHtml(text);
            // For each matching word, create a pattern that matches it even with surrounding punctuation
            matchingWords.forEach(word => {
                // Clean the word of leading/trailing punctuation for matching
                const cleanWord = word.replace(/^[^\w]+|[^\w]+$/g, '').trim();
                if (!cleanWord) return;

                const escapedWord = cleanWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Match the word with optional surrounding punctuation, case-insensitive
                // This handles "God", "God,", "(God)", etc.
                const regex = new RegExp(`(${escapedWord})(?=[\\s,.:;!?'"\\)\\]\\-]|$)`, 'gi');
                result = result.replace(regex, '<mark>$1</mark>');
            });
            return result;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>